1. 从[题目](https://leetcode-cn.com/explore/learn/card/data-structure-binary-tree/4/conclusion/19/)到思路

**自底向上**按前序遍历的顺序来找到p或q存在的可能三个位置:
- 根节点
- 左子树
- 右子树
当第一个节点满足这3个位置中都存在p和q时,它就是LCA.
2. 从思路到步骤
看算法的[动画演示](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/solution/er-cha-shu-de-zui-jin-gong-gong-zu-xian-by-leetcod/)
3. 从步骤到代码

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    private TreeNode ans;
    public void Solution(){
        this.ans =null;
    }
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        // 它把参与方外包了
        treePath(root,p,q);
        return ans;
    }
    // 外包商干活简明扼要,以至于对实例变量this.ans的操作似乎是顺便
    public boolean treePath(TreeNode curRoot,TreeNode p,TreeNode q){
        if(curRoot == null) return false;
        // 根
        int mid = (curRoot.val == p.val || curRoot.val == q.val) ? 1 : 0;
        // 左(子树)
        int leftPath = treePath(curRoot.left,p,q) ? 1 : 0;
        // 右(子树)
        int rightPath = treePath(curRoot.right,p,q) ? 1 : 0;
        // 大于等于2保证了对于一路回溯判断到的当前节点   
        // 不管是在3个位置中的哪里找到了,总之是肯定找到了p或q
        if(mid + leftPath + rightPath >= 2) this.ans = curRoot;
        
        // 当前节点包括它的左子树与右子树在内至少能找到1个p或q
        // 将这个curRoot及其descendents在内的路径标记为true
        // 因为递归不断压栈最后弹栈,其实路径标记为true的过程是一个自底而上的 回溯  的过程
        if(mid + leftPath + rightPath >= 1) return true;
        
        // 这个curRoot和它的descendents都没有希望了
        return false;

    }
}
```
3. 从可执行到健壮
略