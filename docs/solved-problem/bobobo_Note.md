# Interview
1. 有一个合理的思考路径
    - 具有这样的素质最重要:**一定要想办法给出一个思路方向**
    - 算法本身也没有"正确"答案
    - 和面试官一起探讨解决问题
    - **问题的细节与应用环境**

 **Ex**
 1. 如何对一组数据进行排序?
 其实是设计一个接口,排序算法的选择要看应用!
 - 这种数据有什么样的特征?
     - 有没有可能含有大量重复的元素?-->**三路快排**O (nlogn)
     - 是否大部分数据距离它争取的位置?(近乎有序):如银行的业务流程总体有序发生-->插入排序O(n)
     - 是否数据的取值范围非常有限?:如成绩排序-->计数排序
     - 此外,稳定需要吗?快排不稳定,归并
     - 此外,数据的存储用的链表吗?那就得用归并
     - 此外,数据量过大,内存装载不小,需要用[外排序](https://blog.csdn.net/fx677588/article/details/72471357)吗?    
     - 一般整数排序可以用基数,通用可以用堆排序,乱序可以用快速排序.
    - 无需考虑额外空间->可以用空间换时间,**哈希表**
    - 数据规模百万级->O(logn)
    - 设计一个O(nlogn)->需要分治
2. [对一千万条数据进行排序](https://www.cnblogs.com/tntboom/p/4109458.html)---编程珠玑第二版 第一章
    - 每个数字用4byte，1M即可存储250 000个数据.二十五万条数据存入内存，排序，输出到文件i，对一千万条数据完成一次遍历后，生成40个内容有序的临时文件.

再对这些文件归并，

## 时间复杂度
n表示数据规模,O(n)表示运行所需指令数与n的关系.因为省略了常数项,是算法执行的上界.

>看排序原理:对两个整数比较是O(1),对两个字符串是O(n),如果设字符串长度是s,那两个字符串比较其实是O(s).

Title
一个字符串数组n个字符串,先对每一个字符串字母序排序,再对数组字典序排序,问T(n)?
`O(n*slogs + s*nlogn)`

### 最差/最好/平均情况
因此O(n)其实是与用例相关的,得看实际.

### 递归的时间复杂度
以下列求x^n的算法为例,
递归深度:O(log n)
每次时间复杂度:O(1)
```java
public double pow(double x,int n) {
    if(n <= 0) throw new IllegalArgumentException;
    if(n==0) return 1.00;
    // 思路一:计算x^n不好控制次数,可以先计算x^(n/2),这样x^(n/2) * x^(n/2) == x^(n),所以最后return t*t
    // 每一次都除2,一直到等于0,因此深度是O(logn)
        // logn是因为"除了多少次2之后会变成0"(实际是1+logn次),这正是对数的定义
    double t =pow(x,n/2);
    if(n % 2 != 0) // 细节: 如果n为奇数,因为奇数/2会舍掉一次,自己补一个x作为因子乘上去
        return x*t*t;
    return t*t;
}
```
## 数组
```java
int binarySearch(T[] arr,int n,T targrt){
    int l=0,r=n-1;//定义是[l..r]中找target
    while(l <= r)// 根据定义,区间[l..r]当l=r依然是有效的查找范围,因此必须包括l=r
    // 同理当然也可以定义在开区间[l...r)进行寻找,然后每个边界条件都要考虑是否维护了这个定义:
    // int r=n;
    // while(l < r)
    // ...
    {
        int mid= (l+r)/2;
        if(target == mid)
            return mid;
        ...
    }
    return -1;
}
```
必须不断维护**定义**l与r具体的意义,l与r是所谓的**循环不变量**

## 数学
>给出一个正整数N和长度L，找出一段长度大于等于L的连续非负整数，他们的和恰好为N。答案可能有多个，我们需要找出长度最小的那个。
例如 N = 18 L = 2：
5 + 6 + 7 = 18
3 + 4 + 5 + 6 = 18
都是满足要求的，但是我们输出更短的 5 6 7
输入描述:
输入数据包括一行： 两个正整数N(1 ≤ N ≤ 1000000000),L(2 ≤ L ≤ 100)
输出描述:
从小到大输出这段连续非负整数，以空格分隔，行末无空格。如果没有这样的序列或者找出的序列长度大于100，则输出No


```java
import java.util.*;
//(a1+an)*n/2=N
//(a1+a1+(n-1))*n/2=N
//[2a1+(n-1)]n/2=N
//a1=[2N-n(n-1)]/2n
//a1=[2N-L(L-1)]/2L
public class Main{
    public static void main(String[] args){
        Scanner input = new Scanner(System.in);
        int N =input.nextInt();
        int L = input.nextInt();
        for(int i=L;i<=100;i++){
            if((2*N-i*(i-1))%(2*i) == 0){
                int a1=(2*N-i*(i-1))/(2*i);
                System.out.print(a1);
                for(int j=1;j<i;j++){
                    int tmp= a1+j;
                    System.out.print(" "+tmp);
                }
                return;
            }
        }
        
        System.out.println("No");
    }
}
```

