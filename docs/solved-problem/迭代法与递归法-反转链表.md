```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
 /**
 * 反轉的最好方法就是把所有指向依次反轉
 *     而如果是數組得兩邊swap()吧？
 */
class Solution {
    //迭代法
    //这里的头节点是存储值的结点吗？--》是
    public ListNode FENGYINGreverseList(ListNode head) {
        
        //pre定义为当前节点的上一个结点，因此初始时指向null
        ListNode pre = null;
        //current定义为当前被反转的结点,初始时便是head了
        ListNode current = head;
        //next当前被反转fangxiang 结点的下一个结点
        ListNode next;
        //对于每一个结点操作，将每一个结点的方向逆转
        while(current != null){
            next = current.next;
            
            current.next = pre;
            pre = current;
            current=next;
        }
        return pre;
    }

    //递归法
    public ListNode reverseList(ListNode head) {
        //经过守卫条件之后，保证至少有两个结点
        if(head== null || head.next == null)
            return head;
            //压栈到最深，是从最尾部开始反转
        //reversedNode保存压栈到终止条件的那个head
        ListNode reversedNode  = reverseList(head.next);

        //以两个结点为一组，反转它们的指向
        //让下一个节点指向当前结点
        head.next.next = head;
        //当前节点指向null
        head.next = null;

        return reversedNode;
    }
}
```