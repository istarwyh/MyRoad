## 1. 基于LSP的专业英语写作辅助客户端与服务器端设计与开发
## 2. 写作背景
1. 不能及时查找高级词汇运用到作文中
    大学英语在线写作平台的应用研究
2. 编译原理与自然语言处理相分开，因为自然语言的语义，语法，句法都远比编程语言复杂。
3. ![](https://gitee.com/istarwyh/images/raw/master/1604577980_20201105182359284_30406.png)
### 2.1. 需求
#### 2.1.1. 词伙补全（词伙，释义，图片）
#### 2.1.2. 字数提示
#### 2.1.3. 时间提示（图表题/议论文等）
#### 2.1.4. （拼写纠错/非常规表达提示）静态检查
#### 2.1.5. 学术写作规则约束
#### 2.1.6. 英语语言格式化
#### 2.1.7. 提供雅思真题仿写（填鸭式）
### 2.2. 可能的需求
- 添加.english语言的定义
- 添加欢迎页面
- 划词翻译：主要用于写了不确定单词后的场景。主要是通过剪贴板调用翻译API实现。https://mp.weixin.qq.com/s/hB5u-jF5tvwtIeSXa2l4hg

## 3. 竞品调研
### 3.1. 英语作文修改润色
以雅思官方8分范文为例，
Life skills are very important and by doing voluntary work, students learn not only how to communicate with others but also how to manage their time and improve their organisational skills. Unfortunately, teenagers today do not have many after-school activities. After-school clubs are no longer popular and students mostly go home and sit in front of the TV, browse the Internet or play video games.
#### 3.1.1. Grammar
也有office插件，并且会在office里嵌入检查。
![](https://gitee.com/istarwyh/images/raw/master/1604577985_20201105200532272_25822.png)
#### 3.1.2. 改写匠

改写匠的批改结果并不好，所给的三个意见有两个是错的。
![](https://gitee.com/istarwyh/images/raw/master/1604577986_20201105200603069_8904.png)
#### 3.1.3. AI辅助写作
#### 3.1.4. 搜狗翻译
搜狗翻译App的“作文批改”功能，AI写作助手便可针对用户输入的作文内容，指出写作中基础的语法或拼写等错误，提供8种经AI算法优化后的语句润色升级方式。用户还能利用批改前后对照功能，通过“输入-反馈-修正-对比”的良性循环方式，科学、高效的提升写作能力。
### 3.2. 其他
#### 3.2.1. 益加医
https://zhuanlan.zhihu.com/p/139657826
![](https://gitee.com/istarwyh/images/raw/master/1604577984_20201105183335470_27875.png)


### 3.3. Step
把ts服务器与客户端改造成java写的
凑文献


### 3.4. 未知的
#### 3.4.1. 读取pdf
elctron+pdf.js+云函数
React Native 做订阅
#### 3.4.2. 异步调用
```ts
function lazyHookCreation() {
  const inspector = internalBinding('inspector');
  const { createHook } = require('async_hooks');
  config = internalBinding('config');

  hook = createHook({
    init(asyncId, type, triggerAsyncId, resource) {
    // It's difficult to tell which tasks will be recurring and which won't,
    // therefore we mark all tasks as recurring. Based on the discussion
    // in https://github.com/nodejs/node/pull/13870#discussion_r124515293,
    // this should be fine as long as we call asyncTaskCanceled() too.
      const recurring = true;
      if (type === 'PROMISE')
        this.promiseIds.add(asyncId);
      else
        inspector.asyncTaskScheduled(type, asyncId, recurring);
    },

    before(asyncId) {
      if (this.promiseIds.has(asyncId))
        return;
      inspector.asyncTaskStarted(asyncId);
    },

    after(asyncId) {
      if (this.promiseIds.has(asyncId))
        return;
      inspector.asyncTaskFinished(asyncId);
    },

    destroy(asyncId) {
      if (this.promiseIds.has(asyncId))
        return this.promiseIds.delete(asyncId);
      inspector.asyncTaskCanceled(asyncId);
    },
  });

  hook.promiseIds = new Set();
}
```
为什么
```ts
 destroy(asyncId) {
      if (this.promiseIds.has(asyncId))
        return this.promiseIds.delete(asyncId);
      inspector.asyncTaskCanceled(asyncId);
    },
```
总是会调用下面的函数呢？
```typescript
// Called from native. The asyncId stack handling is taken care of there
// before this is called.
function emitHook(symbol, asyncId) {
  active_hooks.call_depth += 1;
  // Use a single try/catch for all hook to avoid setting up one per
  // iteration.
  try {
    for (var i = 0; i < active_hooks.array.length; i++) {
      if (typeof active_hooks.array[i][symbol] === 'function') {
        active_hooks.array[i][symbol](asyncId);
      }
    }
  } catch (e) {
    fatalError(e);
  } finally {
    active_hooks.call_depth -= 1;
  }

  // Hooks can only be restored if there have been no recursive hook calls.
  // Also the active hooks do not need to be restored if enable()/disable()
  // weren't called during hook execution, in which case
  // active_hooks.tmp_array will be null.
  if (active_hooks.call_depth === 0 && active_hooks.tmp_array !== null) {
    restoreActiveHooks();
  }
}
```