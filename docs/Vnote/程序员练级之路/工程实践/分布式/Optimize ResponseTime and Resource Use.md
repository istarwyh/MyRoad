## 1. 原则
### 1.1. 一言以蔽之
- 能批量就不要循环
- 能离线先算就不要在线算
- 能流计算就不要批计算
- 能让数据库算就不要内存算
    - 比如同等数量下的JOIN操作
    - 能利用数据库的任务就不要代码里面配任务
- 能N满足的就不要N+1
- 能保证并发没问题的就并发
    - 能充分利用CPU等计算机资源的就不要过分利用


上述原则都埋了个坑,那就是什么怎么判断"能xxx"?
### 1.2. 能不能？
#### 1.2.1. 流计算的缺点
流计算触发源本身和消息队列投递消息类似，不同的是流计算认为自己投递的是数据在时间维度上的变化，同时定义表为数据在某个时间下的快照。这也称之为流表二象性。流计算本质上也是在处理消息，不同的是实现业务逻辑的Java等程序语言会部分换成SQL，同时程序运行完全托管给Flink这种流计算框架而不用自己操心并发和机器资源的问题。
流本身处理时往往要依赖很多其他的数据，所以JOIN是很常见的操作。这通常要求缓存数据有边界的数据集进行查询，这个边界就是时间窗口。特别地，在双流JOIN中，对于小数据量可以使用`REGULAR JOIN`，即如果有一侧数据流增加一个新纪录，那么它将会把另一侧的所有的过去和将来的数据合并在一起。因为缓存所以不可避免要碰到缓存带来的各种问题。
消息处理中遇到的幂等、消息乱序流计算也一样会遇到。幂等还好办，有主键就可以。消息乱序则要考虑是消息源乱序还是处理时乱序，前者可以对消息源排序，后者则还需要冗余每个消息的顺序键自己做判断。
上述问题没有那么难处理，但是有个问题就在于流计算如Flink本身是自己定义了一堆SQL的，要准确地拼接SQL实现大段的逻辑是很让人痛苦的事情，尤其是在Flink这种作为计算运行框架，本身调试、错误处理机制是不完善的情况下。
当然我们可以用高级语言自定义函数去替代原有SQL，不过这终究失去了原本在应用中方便使用的集成测试、分布式追踪、日志搜索等功能。
## 2. 工具
### 2.1. 线程池
- [Java线程池实现原理及其在美团业务中的实践](https://tech.meituan.com/2020/04/02/java-pooling-pratice-in-meituan.html)
    - 线程数
        - CPU密集型
        - IO密集型
    - 上下文切换成本
- [hippo4j](https://hippo4j.cn/docs/user_docs/user_guide/frame)

## 3. 杂项

### 3.1. 开发查表
开发查询数据库始终有3种选择
一是大宽表，好处是可以充分利用离线计算，应用代码少，查的时候一般效率更高；坏处是笛卡尔积带来大量计算资源，存储资源消耗，表的构建时间也更长，同时宽表数据一致性不容易维护。
另一种是按照范式拆开各表，好处是结构清晰，单表不大；坏处是代码多，要反复和数据库连接查。
最后一种是也拆开表，但是统一用sql在数据库里面操作，避免网络开销，也充分利用数据库的缓存。
实践中可以适量冗余字段，并且尽可能利用数据库的计算能力

### 3.2. 业务逻辑放哪里
业务逻辑写在哪里呢？写在Converter中，写在Service层，写在DAO层，写在SQL里其实都可以，只能说开发人员要把握好各层的边界，尽可能写在Service中内聚业务逻辑。