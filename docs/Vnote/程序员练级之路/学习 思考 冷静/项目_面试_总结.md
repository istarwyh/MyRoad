# 1. 模仿华为云页面
1. 配置路由,让不同的页面可以由`url`进行转发
    1. 路由有一个导出,一个导入
2. 对页面进行分栏布局
3. 在每一个分开的页面上使用devui组件搭建
4. 优化调整每一块的显示
5. 必要的链接关联*事件*与各个页面
---

# 2. VSCode插件开发
## 2.1. 开发背景
为了提升DevUI组件对于使用者的易用性:
1. 针对DevUI组件库目前只有插入代码块的插件，用户可在html文件中输入关键字生成代码块,例如：输入d-button，vscode会自动联想，选中后会出现代码块：
`<d-button (btnClick)=‘’> </d-button>`<sup>[Snippets in VSCode](https://code.visualstudio.com/docs/editor/userdefinedsnippets)</sup>
2. 使用组件的过程中需要查询Demo和API，这个需要不停地切换到组件库网站去查询的过程是比较麻烦的.
因此需求出现了，比如自动补全,输入`<d-`这样的**组件标签**,可以提示`API`并补全,补全完`API`,可以提示**参数**并补全.比如写完了还可以悬浮提示:用户悬停到关键字上，显示相关的描述.
例如：在html中，方便开发者写出`<d-button type=‘‘primary‘’></d-button>`,当写完后鼠标悬浮到type上时，应该出现type的相关描述.
而类型，默认值与说明，应与网站中API页面type的描述保持一致.

目前似乎许多UI库还没有实现将api文档从网站搬到代码中,我们或许可以实现"**api文档赋能页面**".
## 2.2. 开发概述
### 2.2.1. 功能设想
原始版本功能设想如下,鱼骨图靠近鱼头的部分意味着优先级较高,应优先开发
![](https://gitee.com/istarwyh/images/raw/master/1587179601_20200417234150557_1578.png =700x)
做着做着伴随着解bug,新想法又冒出来:依赖查找报警/补全时图片提示/提供GUI的自定义图片....

### 2.2.2. 已有成果展示
~
### 2.2.3. 怎么实现的?
本插件站在了[前辈](https://www.cnblogs.com/liuxianan/p/vscode-plugin-overview.html)的[基础](https://github.com/bauhausr/antd-intellisense)上,以及参考了Angular Language Service插件的解析器部分进行开发,总的逻辑是$获取素材+合适工具=功能实现$.插件开发细节如`函数注册`/`package配置`等请见前辈文章,非常感谢他们的分享!本插件各版本思路如下:
- **1.0**版本思路:通过字符串匹配查找导出的素材模块,在合适的时候调用对应的api完成功能
- **2.0**版本思路:使用面向对象的方法重构代码,素材模块集成导出,提升可扩展性,为3.0资源树对象化做铺垫
- **3.0**版本思路:引入`LSP`,对标签句经过词法/语法/语义分析生成`AST`代替原本的正则匹配,并调用与本地对应的服务器API

题外话:工具怎么找到呢?事先学到了是一个, 读文档看API是一个,读源码溯源是一个.
## 2.3. 功能开发
### 2.3.1. 获取素材
为供api调用,预计网络传输开销大于本地预处理,因此素材可
- 爬虫结果处理后得到素材
- 素材文档在本地由`Java`处理后导出成module模块
- `node_modules`中模块中已集成

素材示例:
```html
export const HTML_SCHEMA=[
"accordion||这是一个accordion组件",
"data||Array<any>或AccordionMenuType||null||数据源||必选，数据源，可以自定义数组或者使用预设的AccordionMenuType||true||false||[]",
"titleKey||string||title||标题的属性名||可选，标题的属性名，item[titleKey]类型为string，为标题显示内容||false||false||[]",
];
```
如果api文档不够规范影响素材处理,可与组件团队协调解决.
### 2.3.2. 使用工具
#### 2.3.2.1. 正则表达式
正则表达式(regular expression)描述了一种字符串匹配的模式（pattern），可以用来检查一个串是否含有某种子串、将匹配的子串替换或者从某个串中取出符合某个条件的子串等。
对于组件的特征

- 如DevUI的组件的`d-button`的`d-`,Antdesign的`Button`大写的`B`

以及引入的模块

- 如`import { DevUIModule } from 'ng-devui'`

开发过程中的操作

- 如敲空格,`[]`(属性),`()`(事件)等

都可以作为正则匹配条件来实现条件限制或触发,代码示例:
```ts
const componentRegex = /<(d-[a-zA-Z0-9-]*)\b[^<>]*$/g;//devui的使用以d-开头,如d-button,以此做触发
const attributeValue= /^=\"[\s\S]*\"(?! |(>)\1)/;// 匹配"",而不是""和空格或者""和>,以此做""不触发而""外可触发的条件限制
```

#### 2.3.2.2. 调用API
通过看vscode自己的API文档[^api],可以打开实现各种功能的新世界
[^api]:[Programmatic Language Features](https://code.visualstudio.com/api/language-extensions/programmatic-language-features)

![](https://gitee.com/istarwyh/images/raw/master/1585274191_20200326123235485_12654.png =600x)
有可能得耐心看,可以逐层了解接口与返回值,以`registerHoverProvider`为例:
![](https://gitee.com/istarwyh/images/raw/master/1587179600_20200417230018072_13732.png =800x)

#### 2.3.2.3. [Language Server Protocol](https://code.visualstudio.com/api/language-extensions/language-server-extension-guide)
微软推出LSP，意图标准化语言工具和代码编辑器之间的通信:
![2](https://code.visualstudio.com/assets/api/language-extensions/language-server-extension-guide/lsp-languages-editors.png =600x)
其实在Angular框架和Jdk中都自带了lsp的实现.
依托于语言或语言工具开发者提供的素材库/符合规范的接口,只要C／S之间建立起可靠的连接(可以是TCP,依靠connection类),**Language Server**就可以解析对应的大量文件，为它们建立抽象语法树，并执行静态程序分析。这可以实现C端包括自动补全,悬浮提示,自动纠错在内的许多功能.
在VS Code中，语言服务器包含两个部分：
- 语言客户端：用JavaScript / TypeScript编写的普通VS Code扩展。该扩展可以访问所有VS Code命名空间API。
- 语言服务器：在单独的进程中运行的语言分析工具。

当在服务器文件中引入`vscode-languageserver`:
```
"dependencies": {
    "vscode-languageserver": "^4.1.3"
}
```
This pulls in the vscode-languageserver library.然后我们就可以使用server的api了.
##### 2.3.2.3.1. LSP类插件基本结构
```
.
├── client // Language Client: able to use vscode API
│   ├── src
│   │   ├── test // End to End tests for Language Client / Server
│   │   └── extension.ts // Language Client entry point
├── package.json // The extension manifest
└── server // Language Server
    └── src
        └── server.ts // Language Server entry point
```
#### 2.3.2.4. 新组件库的语法树
Angular可以通过自身的解析引擎将`html`/`css`/`ts`/`.d.ts`的文件解析成语法树,涉及到前端编译原理的词法分析与语法分析,比如如果只是单独的html文件,可以将每一级标签作为一个`DOM`节点.总体思路是将组件语句经过词法/语法/语义分析打碎成`token`,比如分割成**标签**/**api**/**属性**/**符号**(=""),对每一分割的元素周围划定范围(`keySpan`),可以选择压栈或者简单地放入数组内,最终生成**AST语法树**并构建`map`,使得沿着树枝可以预判下一级的代码.必须注意的是,类似的工作已经有`posthtml`这样的工具做了,并且如果要解析`markdown`之类也有对应的库,自己在开发之前一定要注重程序复用.
这种逻辑可以用在很多方面,**给一个全新的组件库**如`DevUI`,可以沿着`组件-api-属性`这样的链建立单树,如`d-button -- bsStyle -- primary`,每一个组件标签最后可以实现一棵单树,在这样的森林里最后可以对光标周围的某个节点(`position`)读取后上下查找来实现`autofix`或者依赖检查的功能.这样的森林可以通过初始化分析建立`Snapshot`来保存,当局部树(一个component)改变时,作为`dirty data`处理局部刷新快照.在早期(指[2.0版本](https://github.com/istarwyh/DevUIHelper))的时候,可以借鉴这个思路做成Map,也即认为是单节点的树来查询.
可以做到一个配置文件对`DevUI组件`做补全,可以限定这种功能仅当使用组件的同时使用`[]`绑定变量或者`()`绑定函数时被激活,就像`Angular`对基于它自身的`devui`组件做的.[Rome](https://jasonformat.com/rome-javascript-toolchain/#cliusage)的核心思想更进一步，把基于AST（抽象语法树）的所有功能都统一起来，不要每个工具自己做一次AST解析。

##### 2.3.2.4.1. **几个问题**
- 与Angular或者其他工具的AST生成有何不同?
答:主要在于分析的范围,Angular是全文的,并且依赖于ts的解析器;而仅仅分析组件就只有devui的部分:`d-button -- bsStyle -- primary`这样的三级.
- 可以复用其他工具的AST吗?
答:理论上可以,但是要实现如Angular的AST对自己的DevUI不好扩展,且显得臃肿.
- 可以在本地调用markdown的解析包,或者本地实现markdown的解析展示吗?
答:可以试试.

## 2.4. 代码与性能优化
1. 将重复使用的模块如`getName()`导出成模块解耦
2. 考虑插件不必要时不必激活
  - 是否引入了对应依赖,如`@angualr`
  - 是否写了标志性的符号,如`<`或`d-`
  - 是否时对应的文件,`html`或`ts`

值得注意的是,如果是在3.0之前的框架下,这个或许只能考虑读取本地文件[^FileReader]使用正则表达式检测`app.module.ts`中是否引入了`devui`,避免无效启动插件浪费资源;当升级了工具--使用AST来定位元素时,问题就迎刃而解了.
[^FileReader]:[JavaScript进阶学习（三）—— 基于html5 File API的文件操作](https://segmentfault.com/a/1190000006600936#item-3)

3. 多判定结构使用键值对匹配

## 2.5. 上线接受检验!
使用`vsce`打包发布到vscode插件市场,打补丁更新的时候`vsce publish patch`即可.注意可通过`.vscodeignore`省略`test`和`out`等部分.

目前`DevUIHelper`[2.0版本](https://github.com/istarwyh/DevUIHelper)已在VSCode插件市场上线,[3.0版本](https://github.com/sspku-yqLiu/DevUIHelper-LSP)即将全新上线,欢迎`star`,欢迎`issue & pr`,欢迎使用!:)

# 3. P-misson
主要工作是建立数据库并返回后端序列化好的`json`数据,简单调整前端.核心是对SpringBoot的学习.
## 3.1. 概念
Spring/SpringBoot/SpringMVC/Mybatis/Redis
Dao/Service/Entity/Controller

# 4. 难点
所有的难点在于不熟悉.
- 不熟悉项目架构
- 不熟悉基础语法(高级语法反而可查)
- 不熟悉API
你永远不知道一个api能帮你完成什么.....
不熟悉的结果除了开发难以下手,**debug**更是令人痛苦.
技术本身的问题需要依靠基础知识:操作系统的调度,网络通信的建立,路由负载的平衡,数据结构的运用等:
业务的问题更多的还是在于需求,如果一开始能对业务需求了然于胸,也就能知道能否实现,性能,工作量和扩展方面都能取得平衡.
## 4.1. 碰到的最大的困难?
最难的是对已经写好的代码进行解耦.
~原本做过OJ,用的thealeaf,前后端不分离;~
前端项目在入口的`extension.ts`中写全部代码,并且在macos上开发,后来迁移到windows上,并且选择解耦,客户端与服务端分离,每个功能导出模块.

说起来主要是都不会,从零开始,这个正则debug的时间最久,本身对业务逻辑不清晰,正则恰好匹配不容易,就特别容易导致**反复试错**.
### 4.1.1. 正则表达式翻译
1. > `const importRegex = /import[\s\S]*from\s'devui/g;`
    1. `\s` 匹配任何空白字符，包括空格、制表符、换页符等等。等价于` [ \f\n\r\t\v]`
    2. 注意 Unicode 正则表达式会匹配全角空格符;`\S`匹配任何非空白字符。等价于` [^ \f\n\r\t\v]`;
    3. 正则表达式后面的全局标记 `g `指定将该表达式应用到输入字符串中能够查找到的尽可能多的匹配
**检测:**
```js
<script>
var str = "import { Component, OnInit } from '@angular/core';";
var patt1 =  /import[\s\S]*from\s'@angular/core'/g;
document.write(str.match(patt1));
</script>
```
2. >`const componentRegex = /<([A-Z][a-zA-Z0-9]*)\b[^<>]*$/g;`
    1. `[A-Z]`大写字母开头,之后匹配所有字母与数字;
    2. 括号内的表示这是一个分组,将括号内的作为一个整体;
    3. `\b`指示前面为单词的开始或结束(其实代表边界条件);
        1. 123结合代表提取出所有的大写字母开头的单词
    4. `[^<>]*$`指**非**以0个或多个`<>`结尾的
**检测:**
```javascrpt
<script>
var str = "<d-button bsStyle=\"primary\">确认</d-button>";
//   var patt1 = /((d-[a-zA-Z0-9]*)\b)+(?=>)/g;// 这个是一段提取啊,在悬浮提示的静态提取中或许有用?
var patt1 = /<(d-[a-zA-Z0-9-]*)\b[^<>]*$/g;
document.write(str.match(patt1));
// console.log(str.match(patt1));
</script>
 ```
3. >/`\/`package\.json$/.test(fileName)

上面这个正则表达式在mac里运行是<color>true</color>,但是在win里运行就是false,这难道就是传说中的不可移植?

# 5. 问面试官的问题
关注它们的业务
关注它们的技术栈