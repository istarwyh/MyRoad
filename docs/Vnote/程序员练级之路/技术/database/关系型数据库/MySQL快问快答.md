### 1. 索引
#### 1.1. MySQL 索引会常驻内存吗?
会.
#### 1.2. MySQL索引怎么被加载到内存的?
在Linux中,innodb引擎中为`Innodb_buffer_pool`通过`mmap()`直接向操作系统申请内存,每次申请的大小为`innodb_buffer_pool_chunk_size`,最终会申请`innodb_buffer_pool_size`大小的文件映射段动态内存.以上初始化后,`Innodb_buffer_pool`缓存每次查询加载的目录页和数据页,直到`innodb_buffer_pool_size`大小的物理内存占用.直到在线减少`innodb_buffer_pool_size`或是关闭MySQL才会通过`munmap()`方式释放内存给操作系统.[^mysql_memory]
#### 1.3. 既然常驻内存,那MySQL索引如何被淘汰?
无外乎还是那几个缓存淘汰算法。`Innodb_buffer_pool`的内存主要是通过 Free List、LRU List、FLU List、Unzip LRU List 等 4 个链表来进行管理分配。[^mysql_memory]

- Free List：缓存空闲页

-  LRU  List：缓存数据页

- FLU  List：缓存所有脏页

- Unzip   LRU List：缓存所有解压页

[^mysql_memory]: [ MySQL 内存管理初探](https://mp.weixin.qq.com/s/jlFueo-WnR3gILR38uzeIg)

#### 1.4. 为什么选择B+树?
#### 1.5. B+树和倒排索引本质区别是什么?
#### 1.6. B+树的分叉数是多少?
B+树的每个结点都是一个`16k`大小的页,目录结点同理,我们也称为目录页.目录页的数据结构也一样,通常包括File Header等占用的空间有1k,剩下的15k用于存索引键和页号.页号是固定的4byte大小,
1.  假设**索引键是`Bigint`(8byte)**

那么索引页中的一条仅含索引键的数据也就是
<center>4byte + 8byte = 12byte</center>
假设分叉数为N,则
<center>N = 15*1024b/12b = 1280</center>

<span id='1.5'></span>
#### 1.7. B+树一页能存多少数据?
毫无疑问这取决于页中每行数据的大小.
1. 假设**一行数据1K**

那么除去File Header等的空间,还有15k,所以能存15条数据.
#### 1.8. B+树为什么控制层高?一般控制为多少？
首先层级越高,第一次取到目标页的磁盘IO次数就越多.
另一方面,因为层级越高,目标页对应的目录页占用的空间也越大.当内存不足时,部分索引将被淘汰出缓存, 这样下次再访问这些索引结点还需要磁盘IO.因此为了提高性能,用尽可能少的磁盘IO获取页,必须控制层高.
当
1. 只有一棵B+树
2. B+树的层级是3
3. 这颗树是一个完全N叉树
4. 该B+树的每个结点都是`16k`大小的页

则该B+树的大小就是
$16 k + 1280*16k + 1280*1280*16k \approx 2600w KB = 25 GB$
其中，

- 16k: 第一个目录页结点的大小，也是第一层的结点大小
- 1280: 由[1.5](#1.5) 中 的推导得出B+树分叉数为1280

可以看到此时一颗3层的完全B+树索引需要25GB的存储空间。

#### 1.9. 为什么都说Mysql单表不要超过2000w条数据?
假如是3层的满B+树，有多少条数据呢？按照前述的假设可以得到
$1280*1280*15 \approx 2.45kw$

即一颗三层的满B+树大约2400万的数据量。
如果超过这个量级，一方面是初次查询一条数据则可能需要4次IO，绝对会变慢；另一方面是内存无法将这么多索引加载到内存中，频繁汰换内存索引，以及未命中索引的查询增多都会导致此时单表的查询性能大幅下降。
所以会有Mysql单表不要超过2000w条数据的说法。

#### 1.10. 以上算了一遍，然后呢？
上面的讨论有两个很重要的假设：

1.  假设**索引键是`Bigint`(8byte)**
2.  假设**一行数据1K**

所以最后我们推算出Mysql单表不要超过2400w条数据，但实际上索引键的大小和一行数据的大小都不止上面的大小，所以实际中Mysql单表建议的数据量更小，且随着索引键以及一行数据的大小越大越小。
所以我们设计Mysql 表时要注意主键的选择和必要的垂直拆分。