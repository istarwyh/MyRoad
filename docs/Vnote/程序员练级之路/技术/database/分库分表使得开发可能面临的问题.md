# 分库分表使得开发可能面临的问题
当单表数据量过大时，其读写性能都会受到严重影响。一般来说，数据记录1000万行以上&&十亿行以下可以考虑分表；数据库表较多，并且表对应的业务逻辑较为高内聚、低耦合的，可以考虑分库。但是有利就有弊,下面均以TDDL为例说明

## 1. 频繁变动拆分规则
大数据量的分表容易变动拆分规则，每次规则变动都可能涉及到数据的重新搬迁，并且业务端还需要投入大量的人力去维护路由规则
## 2. 主键不严格递增
数据源总是需要一个唯一的主键标志数据库记录，在单库单表的情况下，数据库设置一个唯一自增的主键即可；但是在多库多表的情况下，还需要各个表生成的主键是多库多表下唯一的。通常TDDL会设计一个Sequence表记录全局可用的ID，然后让需要生成记录的节点取回与之前不相同的ID并缓存在应用中以待新增记录时分配ID。当应用用完这批或者重启时会重新向sequence获取ID序列，而每个节点申请到的ID各不相同，这样就保证了全局有唯一主键。
但是从以上TDDL生成主键原理也可以看出来，因为是各自节点自己分配，对于新增的记录主键不一定是严格递增的。

## 3. 分布式事务
当更新内容同时分布在不同库中，不可避免会带来跨库事务问题。可以使用如“两阶段提交” 的方法来解决这个问题，但是除开性能，提交分布式事务时需要协调多个节点，推后了提交事务的时间点，延长了事务的执行时间。导致其在访问共享资源时发生冲突或死锁的概率依然会增高。


## 4. 查询没有分库分表键拖慢查询
有了分库键才能允许TDDL定位SQL具体的执行库表完成SQL对应库名表名的替换。对于单纯的select，如果没有的话需要全库全表扫描；对于分页、Max、Min、Sum、Count这种操作，则还需要在各个分片（Atom）上进行对应的操作，最后将结果汇总到一起（Matrix）再进行计算才能返回结果。



## 5. JOIN操作很慢或者不支持
### 5.1. 问题描述
切分之前，系统中很多列表和详情页所需的数据可以通过sql join来完成。而切分之后，开发面临的只是TDDL暴露的一张逻辑库，可能基于性能考虑，JOIN可能不支持，即使支持性能上也不能接受。
### 5.2. 如何解决
那么原本要通过JOIN获得的能唯一确定需要的记录的字段，就需要先行查出再作为条件去二次查询了。举个例子，取`xxx_no`单据号上最新的目标column字段,也就是要选出`gmt_modified`最大时的column字段，原本可以这样写
```sql
select xxx_no,column,gmt_modified from xxx as a
JOIN
(
    select xxx_no,max(gmt_modified)
    from xxx
    where fenkujian = ? and xxx_no = ?
    group by xxx_no
) as b
on a.xxx_no = b.xxx_no and a.gmt_modified = b.gmt_modified
```
现在需要拆成两步：
1. 
```sql
select xxx_no,max(gmt_modified) as max_gmt_modified  from xxx where fenkujian = ? and xxx_no = ? group by xxx_no;
```
2.
```sql
select xxx_no,column from xxx where fenkujian = ? and xxx_no = ? and gmt_modified = max_gmt_modified;
```
当然如果不是批量操作（比如sql in xxx_no），又希望一步到位的，因为`gmt_modified`一般18位数（yy--mm-dd hh:mm:ss），可以这样写：
```sql 
... SUBSTR(MAX(CONCAT(LPAD(`gmt_modified`,18,'0'),column)),7) ...
```
### 5.3. 注意
- 如果这样写：
```sql
    select xxx_no,column,max(gmt_modified)
    from xxx
    where fenkujian = ? and xxx_no = ?
    group by xxx_no
```
语法上不一定会报错，但是取出来的column其实与`gmt_modified`没有任何对应关系。

- 如果这样写：
```sql
    select xxx_no,column,gmt_modified
    from xxx
    where fenkujian = ? and xxx_no = ?
    group by xxx_no
    having gmt_modified = max(gmt_modified)
```
会报错：`Unknown column 'gmt_modified' in 'field list'`,应该是having中使用的窗口函数需要在select list中出现。

而如果这样写：
```sql
    select xxx_no,column,max(gmt_modified) as gmt_modified
    from xxx
    where fenkujian = ? and xxx_no = ?
    group by xxx_no
    having gmt_modified = max(gmt_modified)
```
那其实就等于
```sql
    select xxx_no,column,max(gmt_modified) as gmt_modified
    from xxx
    where fenkujian = ? and xxx_no = ?
    group by xxx_no
    having 1 = 1
```
