vnote_backup_file_826537664 D:/Test/MyRoad/docs/Vnote/Java/基础知识/从String.Intern()实验看常量加载过程.md

>**字符串常量池本质上是个哈希表，它存储的是字符串实例对象的引用![^jvm]**

[^jvm]:[从字符串到常量池，一文看懂String类](https://mp.weixin.qq.com/s?__biz=MzU5ODg2Njk4OA==&mid=2247484037&idx=1&sn=5f0805bd6c62f690ffa06c3982959889&chksm=febcefc6c9cb66d0cb70d70fac2e4fee73ef2fa32d91f16cb0c6510f5b32ae78f629bb612ddb&mpshare=1&scene=1&srcid=&sharer_sharetime=1593613925350&sharer_shareid=f059618cb093f5efb49a39cd6562e90e&key=7a6ffc80620031bc540a4b92b391e87157b55c88e52904cbb835bda526e0ff1a586d1c6101fb542490828c08cdfce2866392d015927be5907d84463dc26371ef31dd9fe02f79e0fb09eb956dbbf22976&ascene=1&uin=MTM2NzczNTcyNQ%3D%3D&devicetype=Windows+10+x64&version=62090070&lang=zh_CN&exportkey=A8edtILws1QNJsxnTLC8Iqs%3D&pass_ticket=aFoiqjOTcc8UhC9qVxDI%2BkM0NqWcoqXdVcdpjeCgXbTcKBGqej6Xds48IfMw5j8m)

```java
/**
 * @date 2020年7月1日
 * @JDK 8
 */
public class Solution {

    public static void main(String[] a){
     /**
         * 如果是通过new关键字加StringBuilder/StringBuffer的方式创建字符串对象,字符串常量池中一开始没有它的引用
         */
        String s1 = new StringBuilder("se").append("ven").toString();
        String s2 = new StringBuilder("se").append("ven").toString();

//        但是在JDK7之后，调用intern()时会发现堆上已有“seven”实例，故复制s1这个引用加入字符串常量池中，并返回这个引用
        System.out.println(s1.intern() == s1); // 2. true
//        s2.intern()与2.同理返回的也是s1
        System.out.println(s2.intern() == s1); // 3. true
//        但是s2本身通过了new关键字又会在堆上创建一个同样的“seven”实例，但是有着不一样的引用
        System.out.println(s1.intern() == s2); // 4. false

        /**
         * 而直接赋值,其实执行的是以下代码:
         *             String s;
         *             s = findInStringTable("dija");
         *             if(s!=null) return s;
         *             s = new String("dija");
         *             s.intern();
         *             return s;
         *  可以发现一定会有这个字符串实例的引用被加到了字符串常量池中
         */

        String s3 = "dijia";

        String s4 = new StringBuilder("di").append("jia").toString();
//        因为字符串常量池中已经存在了s3的引用，故返回的是s3
        System.out.println(s4.intern() == s3); // 5. true
//        与4.同理
        System.out.println(s4.intern() == s4); // 6. false，

        /**
         * 使用String的构造函数反而是很低效的创建字符串的方式
         *      因为在解析常量“daina”的时候是第一次解析，JVM会在堆中创建“daina”这个实例，并把其引用添加到字符串常量池中（{1}）
         *      而当遇到new时，则又会在堆中创建一个“daina”实例并返回这个实例的引用（{2}）
         */
        String s5 = new String("daina");
        s5.intern();
        String s6 = "daina";
//        s6是JVM自动创建的对象实例引用，s5是new关键字创建的对象实例引用({2})
        System.out.println(s5 == s6); //7. false

        String s7 = new StringBuilder("tai").append("luo").toString();
        s7.intern();
        String s8 = "tailuo";
        System.out.println(s7 == s8);//8. true

//        算是我学习中的彩蛋吧:)
//        和《深入理解JVM》Page63的实验不一样,这里结果是true
//        明明说好的sum.misc.Version加载时“java”字符串的引用已进入常量池
        String str = new StringBuilder("ja").append("va").toString();
        System.out.println(str.intern() == str); // 1. true

    }

}

```