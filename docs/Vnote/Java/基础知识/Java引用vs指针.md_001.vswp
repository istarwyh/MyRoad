vnote_backup_file_826537664 D:/Test/MyRoad/docs/Vnote/Java/基础知识/Java引用vs指针.md
---
app:markdown
---
实践中发现蹊跷,java中的引用不能实现C/C++中指针同样的swap():

## 1. 引用与C++中的指针
### 1.1. C中的swap()
对于C/C++，语言的操作是在内存级别上的，这赋予的能力是超过寻常语法的。
如果确定输入参数是`int`型可以通过指针间接访问内存交换，
```c
void swap(int* x,int* y){
    int tmp = *x;
    *x = *y;
    *y =tmp;
}
```
对于更多不确定的类型如`double`乃至`泛型`(`void*`,可以简单理解为可以被任何类型赋值[^void*与Object])可以直接内存拷贝：
[^void*与Object]:void*表示通用指针，可以被任何类型赋值；Java中`Object`同理，并且Java中对象在运行时擦除后也都是Object.

```c
void swap(void* x,void* y,size_t size){
    char tmp[size];
    //memory copy的意思
    memcpy(tmp,x,size);
    memcpy(x,y,size);
    memcpy(y,tmp,size);
}
```
### 1.2. C++中使用引用（`&`）的swap()
C++中的引用变量是一个别名，封装了**对引用指向的变量本身的操作**但是不把指针暴露在外。
与指针的区别便是除了对变量本身的操作，不能在内存上操作。
与Java中引用的不同，在于Java中的引用其实是被剥夺了访问能力的指针。
```c++
void swap(int& x, int& y)
{
   int tmp = x; /* 保存地址 x 的值 */
   x = y;    /* 把 y 赋值给 x */
   y = tmp; /* 把 x 赋值给 y  */
  
   return;
}
```
### 1.3. Java中的swap()
```java
class SwapTest { 

    // int x=5,y=6;就不试了，本来就是传递值被拷贝。
    Integer x = 5, y = 6;
    
    public static void swap(Object x, Object y){
        Object t = x; x = y; y = t; 
    }
    public static void main(String[] args){ /
        // 尽管传递参数是对象
        Integer x1 = 5, y1 = 6; 
        swap(x1, y1); 
        // 结果没有变,只能解释为swap()函数内部的引用变量依然是对传入引用的拷贝
        System.out.println(x1+" "+y1); // 输出的是5 6 
        
        // 主函数中引用互换
        Object t = x1; x1 = y1; y1 = (Integer) t;
        System.out.println(x1+" "+y1); // 输出的是 6 5

        // 使用实例变量交换
        SwapTest s = new SwapTest(); 
        swap(s.x, s.y);
        // 实际上这里传进去的依然还是引用，这个引用通过解引用（后文有解释）得到
        // 这个引用指向在堆上的实例变量
        System.out.println(s.x+" "+s.y); // 输出的是5 6
    } 
}
```
### 1.4. 其他swap()
#### 1.4.1. 动态类型或者语法糖支持的语言

类型是对内存的抽象；类型系统的存在是为了避免代码以无效的使用方式编译或运行
迭代器是为了泛型编程对不同数据结构**遍历**操作的抽象。

swap()甚至可以：
```go
int b,a;
b，a = a, b;
```
#### 1.4.2. 特殊情况下不需中间变量的swap()
```java
void swap(int[] a,int i,int j){
    a[i] = a[i] + a[j];
    a[j] = a[i] - a[j];
    a[i] = a[i] - a[j];
}
```


## 2. java中只有值传递吗?
### 2.1. 进一步了解的好处
对`JVM`的内存模型有了解，就会明白无论传入的只能是值，至于这个值怎样被解析，是拷贝还是做副本，是需要实践验证的，只是上述的实验已经足够了。而对于初学者，可能更习惯于从语法层面上实验种种情况。
### 2.2. 不看本质的实验

 Java中只有值传递[^凌凌小博客],着重测试引用传递的情况
[^凌凌小博客]: [java函数（方法）中的值传递和引用传递问题](https://blog.csdn.net/qq_35923749/article/details/79703700)

```java
import java.util.Date;
public class Test{
    Date x = new Date(1234567);
    Date z = new Date(7654321);
    
    public static void main(String[] args){
        Date y = new Date(7654321);
        
        //主函数调用
        y = new Date(1234567);
        System.out.println(y.getTime());// 可以改变
        
        //引用值传入
        m1(y);
        System.out.println(y.getTime());//不能改变        

        // 实例变量传入-01-函数内部有局部变量
        Test t = new Test();
        m1(t.x);
        System.out.println(t.x.getTime());//不能改变
        
        // 实例变量传入-02
        m2(t.x,y);
        System.out.println(t.x.getTime());//不能改变

        // 实例变量传入-03-参数都是实例变量
        m3(t.x,t.z);
        System.out.println(t.x.getTime()+" "+t.z.getTime());//不能改变
        
        // 局部变量传入-04
        // 唯一能改变的情况是改变对象实际内容
        m4(y);
        System.out.println(y.getTime());// 可以改变


    }
    // 测试方法内部引用被改变,主函数内部是否改变
    public static void m1(Date data){
        // data = new Date(7654321);
        Date date = new Date(7654321);
        data = date;
    }

    // 同上,只是参数来自于传入的引用而不是函数内部产生的
    public static void m2(Date data,Date date){
        data = date;
    }

    // 测试参数都是实例变量的引用的互换是否成立
    public static void m3(Date data,Date date){
        Date tmp = data;
        data = date;
        date = tmp;
    }

    // 测试是否可以在函数内部改变对象的内容
    public static void m4(Date data){
        data.setTime(7654321);
    }
}
```
## 3. 总结
### 3.1. 指针的特点
>通过指针，可以对内存进行低级控制，从而可以基于系统底层处理细节写出精细的代码，但是这同样加大了编程复杂度。--陈皓

C/C++传递参数一般同样是值传递，但是也可以传递指针。
当其为值传递时，对于`外建类型`（自定义的数据结构），依然是一个深度拷贝。这一方面带来时间和空间上的开销，一方面避免了内存共享的问题。
### 3.2. 引用的特点
1. 当把Java的**基本数据类型(如int,char,double等，又称为`内建类型`)作为入口参数**传给函数体的时候,传入的参数在函数体内部会被**拷贝**一份而变成局部变量,其生命周期也即在函数内部,而所有的函数体内部的操作都是针对这个**拷贝**的操作,它影响不到作为输入参数的变量.这种参数传递的方式也即"值传递".
2. 但是在Java中用**对象（`外建类型`）作为入口参数的传递**则缺省为**引用传递**,尽管实际上传递的是引用**值**.参考"值传递",在方法内部无论对对象的这个引用值做了何种操作，都不会改变实参对象的*引用* .
3. 但是如果在方法内部**通过这个引用修改其所指向内存处的值**时,实质上就是在**对这个对象的直接操作**.
```java 
public void change(int[] source) {
       source[1]=13579;//source[1]的值被真正改变为13579
    }
```

4. 因为Java是基于**内存共享**来操作内存变量。这大大提高了内存复制带来的麻烦与效率，但这同样带来并发变量不确定以及野引用的问题。
5.  Java中的引用设计为不支持`+`/`-`这类算数运算,即Java的引用只能指向程序当前限定的对象,又引入`GC`,解决了部分内存共享的问题
### 3.3. 拓展
1. 除了对象作参数时是"引用传递",在任何时候用"`=`"向对象变量赋值时也都是引用传递.这意味着当`objA = objB`时,此后任意对objB的改变都等同于对objA的改变,反之亦然:  
```java
       
       class ChangeObj{
    String str = "Hello";
}
public class Test{

    public static void main(String[] args) {
        ChangeObj objA = new ChangeObj();
        ChangeObj objB = objA;
        objA.str = "World";
        System.out.println(objB.str);// 输出World
        objB.str = "Kitty";
        System.out.println(objA.str);// 输出Kitty
    }
}
```
**注意**
`obj.str`的操作被称为解引用(《CodeComplete2》),可以理解为通过像句柄的`obj`来找到指向所要成员变量的引用（这里是`str`）。

2. 要使得objB诞生于objA,但是objB之后与objA又没有直接的关系,即实现C++的**拷贝构造**，需要使用`prototype`设计模式。
    - 借助`Object.clone()`[^Note]方法实现深拷贝[^深拷贝],即让原始对象和拷贝之后的对象引用不指向同一块堆内存. 
    - `Object.clone()`介于`new`一个对象与`=`之间，从引用和堆中对象的关系： `=`$\iff$浅拷贝 $\leq$ `new`$\leq$深拷贝.

[^Note]: 调用对象的 clone 方法，必须要让类实现 Cloneable 接口，并且覆写 clone 方法

[^深拷贝]:将每个引用类型都拆分为基本类型，分别进行Object.clone()[^浅拷贝]

[^浅拷贝]:[Java的深拷贝和浅拷贝](https://www.cnblogs.com/ysocean/p/8482979.html)

**注意**
5. 对于`String`类,在方法内部通过引用值(在方法调用栈中)也无法修改之前在堆区申请的那段内存,因为它的底层是char数组.  

## 4. 思考
王垠认为,Java中`int`这种基本类型变量因为是原始类型,无法用`*`或者`.`访问成员变量,所以它们在**实现上**是传递值还是引用类型对于程序员没有区别.而在实际实现时,因为`innling`,将基本类型如`int`优化成值类型的传递.那`null`是引用类型,不能转换为基本类型,这又该如何解释?
## 5. References
