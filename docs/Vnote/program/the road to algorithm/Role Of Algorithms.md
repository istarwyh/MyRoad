---
reference_link: https://mp.weixin.qq.com/s/ErbpSgF-UueOEntNahKW6g
author: matklad;dingtingli
---
## 1. 提升编程质量

算法不仅仅是技术学习的目的，而是一个锻炼工具。

就像人们进行进行有氧或力量训练，并不仅仅是因为在日常生活中经常需要举重或运动。相反，现代生活中的体力活动大大减少，所以我们需要额外锻炼来保持身体健康，这对我们的日常生活具有实际意义。

通过算法的挑战性训练，开发者可以加强编写无 bug 代码的能力。因为一个细小的编程失误在算法中可能会导致失败，这强调了编写精确代码的重要性。

比如，编写一个排序算法（如快速排序）时，一个小小的索引错误或边界条件处理不当可能会导致整个算法失败。这要求开发者仔细思考每一行代码的作用，并通过这种精细化的思考过程，培养起对代码质量的高要求。

## 2. 理解核心原则

算法培养了对属性（properties）和不变性（invariants）的深入认识。这些元素构成了大型成功系统的骨架。通过直观的算法训练，开发者能够快速理解、测试并获得清晰的反馈，从而深入掌握这些原则。

比如，在学习二分搜索算法时，开发者必须理解不变性的概念，即循环每次迭代保持搜索空间缩小一半的性质。这种不变性的理解有助于在更复杂的系统中识别并应用类似的原则，例如在数据库索引或者分布式系统的数据分区中。

这些核心属性和不变性往往是支撑大型和成功系统的基础。90% 的代码只是无关紧要的和粘合剂，但如果你能识别出那关键的 10% 的内容，你就能更快地理解整个系统。

## 3. 提供思考框架

算法为解决实际问题提供了思考框架。众多的算法概念，如二分查找、堆排序等，在不同的应用场景中以不同的方式反复出现。识别这些熟悉的结构和模式是至关重要的。

比如，在缓存数据时使用哈希表，这要求开发者理解哈希表的基本概念：通过哈希函数映射键值来快速存取数据。这个思考框架能帮助在处理其他需要快速存取数据的场景下设计高效的解决方案，比如在构建一个高速缓存系统（如 Memcached）时。

## 4. 小规模到大规模的迁移

在小规模编程中培养的技能和洞察力很可能适用于大规模的软件开发。这提出了一个有趣的观点，即通过练习小规模的问题可能会增强处理大规模问题的能力。

在小规模编程中掌握递归的思想，如实现一个简单的文件搜索功能，可以迁移到大规模的系统设计中，比如使用递归下降算法来构建编译器的解析器。这种能力的转移说明了小规模编程技能在更大的设计中的适用性。

## 5. 算法与其他概念的连接

上面这些建议在深层次上形成了一个相互连接的网络，为许多理论提供了基础。因此，如果你对编程学习充满好奇，算法会深入到这些基础之中。我想在这里再次明确算法与其他概念的连接：

**线性搜索（linear search）**

在一些古老的函数式编程语言中，数据通常通过关联列表来存储键值对。这种数据结构以列表的形式保存每个键值对。当需要检索特定的键时，使用线性搜索——即从列表的开始处逐个遍历元素，直到找到匹配的键。

由于这种方法按顺序检查每个元素，其效率较低（时间复杂度为 O(n)），尤其是与现代编程语言中常用的更高效结构（如哈希表，其查找效率通常为 O(1)）相比。因此，关联列表和线性搜索在古老的语言中是常见的数据存储和检索方式。

**二分搜索（binary search）**

二分搜索是一种高效的查找算法，用于有序数据集。它通过每次将搜索范围减半来快速定位元素，具有对数时间复杂度（O(log n)）。

相比之下，`partition_point` 是二分搜索的一个更通用形式，用于在满足特定条件的有序序列中找到分割点。

这种方法的核心在于：进行 `k` 次比较最多能区分 `2^k` 个不同结果，因此在 `n` 个元素中找到目标至少需要 `log2(n)` 次比较，这也是算法效率的下界。

简而言之，二分搜索不仅高效，而且其原理在理解算法复杂性方面具有重要意义。

**二次排序（quadratic sorting）**

在实际工作中，二次排序算法如冒泡排序、选择排序和插入排序，由于其实现简单，经常用于处理小型数据集。

这些算法的代码量较少，易于理解和维护，特别适合数据集大小受小常数限制的情况。尽管它们的时间复杂度为 O(n²)，但在小数据集上仍表现出足够的效率。

在新语言环境或对算法复杂性和错误风险有担忧的情况下，二次排序算法由于其低风险和易于实现的特性，成为了一种实用的选择。

**归并排序（merge sort）**

归并排序，特别是其变体如 k-路归并，是磁盘上排序和LSM-树（日志结构合并树）工作机制的核心。

在处理大数据集时，归并排序优化了磁盘 I/O 操作，通过分批处理适合内存的数据量来有效管理资源。

LSM-树，尽管在学术教育中不太突出，实际上在数据库和存储系统中扮演着关键角色，它通过批量写入和合并操作来提高写入效率和减少磁盘 I/O。这种方法在处理大规模数据时尤其重要，有效平衡了性能和资源消耗。

**堆排序（heap sort）**

堆排序是一种高效的排序算法，特别适用于内存限制的场景，如操作系统内核。它利用堆结构（一种特殊的二叉树）实现就地排序，不需要额外内存空间。

其主要步骤包括构建堆和逐个移除堆顶元素重建堆，以此达到排序目的。堆排序的时间复杂度为 O(NlogN)，保证了较高的效率。

这些特点使得堆排序在需要节省内存且要求相对稳定排序性能的场合中，如内核级操作，成为了一个理想的选择。

**二叉堆（binary heap）**

二叉堆是一种完全二叉树结构，广泛应用于优先队列的实现，分为最大堆和最小堆。

在简易计时器中，二叉堆根据任务的过期时间管理任务顺序，快速处理最近的事件。

在 Dijkstra 算法中，它高效选择最短路径的下一节点。

而在 k-way-merge 方法中，二叉堆用于合并多个排序序列，每次选出最小元素。

这些应用中，二叉堆提供了快速插入、删除和访问优先级最高（或最低）元素的能力，使其成为处理这类问题的理想选择。

**可扩展数组（growable array）**

可扩展数组是一种动态扩容的数据结构，其容量根据增长因子自动调整。

当增长因子设为 2 时，每次扩容数组大小翻倍，导致在 n 次扩展后，新数组大小超过所有之前尺寸之和。这造成内存分配器无法重用原有空间，需在内存中另寻足够大的连续区域，增加内存碎片化风险。

因此，较小的增长因子（小于2）更受青睐，因为它能更平衡地管理内存使用，减少碎片化，尽管可能需要更频繁地进行数组扩展。

**双向链表（doubly-linked list）**

双向链表是一种链式数据结构，其中每个节点都包含数据部分以及指向前驱节点和后继节点的两个链接。

这种结构允许在两个方向上遍历：既可以从头节点向尾节点，也可以从尾节点向头节点。

与单向链表相比，双向链表在进行某些操作时，如节点的插入和删除，提供了更高的效率和灵活性，因为它可以直接访问前一个节点，而不需要从头开始遍历。

这种链表广泛应用于需要双向遍历和高效插入、删除操作的场景。

**二叉搜索树（binary search tree）**

二叉搜索树（Binary Search Tree，BST）是一种常用的数据结构，其中每个节点包含一个键值，且每个节点的左子树只含有小于节点键值的节点，右子树只含有大于节点键值的节点。这种结构使得查找、插入和删除操作能够高效进行。

而 Monoid 树是基于二叉搜索树的变体，应用数学中的Monoid  概念，即带有结合性的二元运算，如求和或寻找最小值。Monoid 树优化了特定类型数据的合并与区间查询，使其在处理组合性数据时更高效。

**AVL树（AVL tree）**

AVL 树是一种自平衡二叉搜索树，命名源自其发明者 Adelson-Velsky 和 Landis。

在这种树中，任意节点的两个子树的高度差最多为 1，保证了树的平衡。为了维持这种平衡，AVL 树在插入和删除节点时可能需要通过“旋转”操作进行调整，包括小左旋、小右旋、大左旋和大右旋。

这些旋转确保了树在所有操作后仍然保持平衡，使得在树中查找、插入和删除操作都能在对数时间内完成，保证了高效的性能。

**红黑树（Red Black Tree）**

红黑树是一种自平衡的二叉搜索树，可以看作是 2-3 树的二叉表现形式，进而与B树类似。

它通过特定规则维持平衡，如限制红色节点的连续性，确保高效的搜索、插入和删除操作。

左倾红黑树是其变体，以更简洁的方式实现，但由于其非对称性，处理某些操作可能更复杂。

这种树结构广泛应用于各种计算机系统中，如数据库，因其在保持数据平衡和提高操作效率方面的优势。

**B 树（B-tree）**

B 树是一种自平衡树形数据结构，特别适合用于数据库和文件系统，因为它能高效地处理大量数据。

在 Rust 编程语言中，B 树因其优秀的性能和安全性特性而被广泛使用，其标准库中的 `BTreeMap` 和 `BTreeSet` 提供了高效的数据存储和管理方式。

在数据库领域，B 树是常见的数据存储和索引结构，特别是因为它与计算机的内存层次结构高度契合，减少磁盘 I/O 操作，提高了数据访问效率。

B 树在数据库中的普遍应用，部分归因于其优化磁盘读写和降低数据访问成本的能力。

**伸展树（Splay Tree）**

伸展树是一种自调整的二叉搜索树，以一种称为“伸展”的操作来优化连续的搜索效率。

当一个元素被访问时，伸展树通过旋转将该元素移到树的根部，从而使最近访问的元素更容易再次访问。

这种结构特别适合于实现缓存和内存管理策略，因为它能够适应访问模式，减少未来访问的平均路径长度。

伸展树不需要存储额外的平衡信息，因此在空间效率上也优于其他自平衡二叉树，如 AVL 树或红黑树。伸展树的自调整特性使其在实际应用中对于访问模式变化具有很好的适应性。

**哈希表 (HashTable)**

哈希表是一种通过哈希函数快速定位数据的高效数据结构。它支持快速查找、插入和删除操作。

解决哈希冲突的两种主要方法包括链式存储和开放寻址。链式存储通过在每个槽位上维护一个元素链表来处理冲突；而开放寻址则在表中寻找空槽位。

由于其高效的数据访问能力，哈希表在数据库索引、缓存实现、关联数组等多种计算机科学领域中有着广泛应用。不同的冲突解决策略使得哈希表在各种场景下都能保持良好的性能。

**深度优先搜索 (Depth First Search)**

深度优先搜索（Depth First Search, DFS）是一种用于遍历或搜索树和图的算法。它从一个节点开始，沿一条路径深入探索直至末端，然后回溯以探索其他路径。

DFS 特别适用于需要完全访问所有节点的场景。在处理有向无环图，如软件项目中模块的依赖关系时，DFS 常被使用。

**广度优先搜索 (Breadth First Search)**

广度优先搜索（BFS）和深度优先搜索（DFS）是两种主要的图遍历算法，各有适用场景。

BFS 按层次顺序遍历节点，适用于寻找最短路径或层级相关的问题，如在文件系统的遍历中使用的就是 BFS。

相比之下，DFS 深入探索每个分支，直到无法继续，适合于空间受限或需要访问所有节点的情况。

两者没有绝对的优劣，而是根据具体需求和应用场景来选择最合适的算法。

**拓扑排序 (Topological Sort)**

拓扑排序是对有向无环图（DAG）中顶点的排序方法，用于处理有依赖关系的元素。它确保每个元素都在其依赖项之后出现，从而保持依赖顺序。

这在任务规划、项目管理等场景中至关重要，尤其是当任务之间存在明确的先后依赖时。

例如，在软件构建中，某个模块必须在它依赖的模块之后编译。拓扑排序不仅帮助安排任务顺序，还能检测依赖中的冲突，如循环依赖，从而保证整个流程的有效和顺畅执行。

**强连接组件 (Strongly Connected Components)**

强连通组件（SCC）是有向图分析中的一个关键概念，指图中任意两节点间存在双向可达路径的节点集合。SCC 的研究在处理元素间存在双向依赖关系的系统中尤为重要。

例如，在解决二元可满足性问题（2-SAT）时，SCC 的应用可以实现多项式时间内的问题求解。

虽然在实际应用中不常遇到，但理解 SCC 对深入掌握复杂逻辑问题（如三元可满足性问题，3-SAT）的本质具有重要价值。简言之，SCC 不仅是图论的基础概念，也是解决某些算法问题的关键工具。

**最小生成树（Minimal Spanning Tree）**

最小生成树（MST）是图论中的一个关键概念，它连接图中所有顶点，同时保持总边权最小。MST的构建与排序紧密相关，因为边的选择常基于权重排序。

此外，它也与不相交集合结构关联，该结构帮助检测并避免循环。

在某些实现中，比如普里姆（Prim）算法，二叉堆作为优先队列使用，以高效选择最小边。

MST为复杂的旅行销售员问题（TSP）提供了近似解，展示了简单问题（P类）与困难问题（NP类）之间的联系，兼顾了计算效率和解的质量。

**Dijkstra**

Dijkstra 算法，由著名计算机科学家 Edsger W. Dijkstra 提出，是图论中寻找最短路径的经典算法。

在其高效实现中，常用到堆这种数据结构，特别是优先队列，以快速找到最近未访问节点。

**Floyd-Warshall**

Floyd-Warshall 算法是一个在图论中计算所有顶点对最短路径的经典算法，它基于动态规划的思想。

这个算法不仅在图的路径分析中重要，还意外地适用于将有限状态机（FSM）转换为等效的正则表达式，这是自动机理论中的一个高级概念。

通过这种方式，Floyd-Warshall 展示了动态规划的强大和多功能性。理解这个算法意味着深刻掌握了动态规划的核心原理。尽管 Floyd-Warshall 算法可能初看起来复杂，实际应用却相对直观和简单。

**Bellman-Ford**

Bellman-Ford 算法在图论中用于寻找最短路径，尽管实际应用不如其他算法广泛，但它在理论上极为重要。

该算法的核心在于固定点迭代原理和边缘放松技术。通过反复更新路径长度，直到达到稳定状态（即路径长度不再变化），算法能够处理负权边的情况。

这个过程展示了如何逐步逼近问题的解决方案，为理解更复杂的图论算法提供了基础。在学习固定点迭代时，其与最短路径问题的相似性变得尤为明显。

**二次子字符串搜索（Quadratic Substring Search）**

二次子字符串搜索是一种在文本中查找子字符串的基础算法，通常作为编程语言标准库的一部分提供。

这种算法的时间复杂度为 O(n²)，意味着其性能会随着文本和子字符串长度的增加而急剧下降。它通过在主字符串中逐个位置检查是否匹配子字符串来工作。

尽管实现简单，但在处理大文本或频繁搜索时效率较低，因此对于大数据量或高效率需求的场景，更高级的搜索算法（如KMP、Boyer-Moore或Rabin-Karp）通常是更优选择。

**Rabin-Karp**

Rabin-Karp 是一种基于哈希的字符串搜索算法，它通过计算模式字符串和文本中的子字符串的哈希值来快速识别匹配项。

算法首先计算模式字符串的哈希，然后遍历文本中的子字符串，对每个子字符串计算哈希值并与模式字符串的哈希比较。如果哈希值相匹配，进一步检查以确认是否真正匹配。

这种方法特别适用于高效地搜索大文本中的多个模式，因为比较哈希通常比直接比较字符串更快。

**Boyer-Moore**

Boyer-Moore 算法是一个在实际字符串搜索中非常高效的方法，广泛应用于各类搜索工具，如 ripgrep。

这个算法独特之处在于它不需要检查文本中的每个字符，而是通过其巧妙的坏字符规则和好后缀规则，允许在搜索过程中跳过某些部分，从而显著提高搜索效率。

这种优化手段使得 Boyer-Moore 在性能上超越了许多理论预期，其设计的简洁性和实用性相结合，构成了计算机科学中的一个经典例子。

**Knuth-Morris-Pratt**

Knuth-Morris-Pratt（KMP）算法是一种高效的字符串搜索算法，代表了有限状态机（Finite State Machine, FSM）的典型应用。

这种算法通过特定的模式匹配策略，避免在文本串中的不必要回溯，从而提高搜索效率。KMP 算法的核心是利用已匹配的部分信息，减少重复比较。

它不仅是字符串搜索领域的一个重要算法，而且与其他算法如 Aho-Corasick 紧密相关，后者扩展了KMP的原理，允许同时搜索多个模式串。KMP 算法的设计和应用体现了有限状态机在计算机科学中的普遍重要性。

**Aho-Corasick**

Aho-Corasick 算法是一种高效的字符串搜索算法，融合了 Knuth-Morris-Pratt (KMP) 算法的匹配策略和Tries（前缀树）的结构。

作为一种有限状态机，它能同时搜索多个关键字，特别适用于模式匹配问题。

Aho-Corasick 的状态机特性使它能够扩展到更复杂的应用中，如实现正则表达式的模式匹配和模糊搜索。

通过构建有限状态机的乘积，它可以有效处理多模式字符串搜索，提供灵活且强大的搜索能力。

**编辑距离（Edit Distance）**

编辑距离是一种衡量两个字符串差异的方法，通过计算将一个字符串转换成另一个所需的最少编辑操作（插入、删除、替换）。

在生物信息学中，这用于比较 DNA 序列，分析它们的相似度或进化关系。这与传统编辑距离相似，但可能涉及更复杂的场景。

它如何利用 CPU 的并行处理能力优化算法性能，这对于处理大型数据集，如大型基因序列，尤其重要。

## 6. 总结

算法不只是一个孤立的学习领域，而是与整个软件工程领域紧密相连。尽管在日常开发中可能不直接使用算法，但其带来的思维训练和技能锻炼是无价的。此外，解算法，明白他们与基础概念的关联，以及基于他们的 API 甚至产品的实现又有助于我们更好地运用这些 API 或者产品。